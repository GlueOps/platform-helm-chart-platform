apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: external-secrets
  annotations:
    argocd.argoproj.io/sync-wave: "5"
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  destination:
    name: "in-cluster"
    namespace: glueops-core-external-secrets
  project: glueops-core
  syncPolicy:
    syncOptions:
      - CreateNamespace=true
      - ServerSideApply=true
    automated:
      prune: true
      selfHeal: true
    retry:
      backoff:
        duration: 10s
        factor: 2
        maxDuration: 3m0s
      limit: 5
  ignoreDifferences:
  - group: apiextensions.k8s.io
    kind: CustomResourceDefinition
    jsonPointers:
    - "/spec/conversion/webhook/clientConfig/service/name"
    - "/spec/conversion/webhook/clientConfig/service/namespace"
  source:
    repoURL: ghcr.io/external-secrets/charts
    chart: external-secrets
    targetRevision: 0.19.2
    helm:
      parameters:
        - name: webhook.hostNetwork
          value: "{{ .Values.host_network.enabled }}"
        - name: webhook.port
          value: "{{ .Values.host_network.external_secrets.webhook_port }}"
        - name: webhook.metrics.listen.port
          value: "{{ .Values.host_network.external_secrets.webhook_metrics_port }}"
        - name: webhook.metrics.service.port
          value: "{{ .Values.host_network.external_secrets.webhook_metrics_port }}"
        - name: image.repository
          value: "{{ .Values.container_images.app_external_secrets.external_secrets.image.registry }}/{{ .Values.container_images.app_external_secrets.external_secrets.image.repository }}"
        - name: image.tag
          value: "{{ .Values.container_images.app_external_secrets.external_secrets.image.tag }}"
        - name: webhook.image.repository
          value: "{{ .Values.container_images.app_external_secrets.external_secrets.image.registry }}/{{ .Values.container_images.app_external_secrets.external_secrets.image.repository }}"
        - name: webhook.image.tag
          value: "{{ .Values.container_images.app_external_secrets.external_secrets.image.tag }}"
        - name: certController.image.repository
          value: "{{ .Values.container_images.app_external_secrets.external_secrets.image.registry }}/{{ .Values.container_images.app_external_secrets.external_secrets.image.repository }}"
        - name: certController.image.tag
          value: "{{ .Values.container_images.app_external_secrets.external_secrets.image.tag }}"
      values: |
          {{- toYaml .Values.glueops_node_and_tolerations | nindent 10 }}
          webhook:
            certCheckInterval: "30s"
            hostNetwork: true
            port: 10751
            {{- toYaml .Values.glueops_node_and_tolerations | nindent 12 }}
          certController:
            requeueInterval: "30s"
            {{- toYaml .Values.glueops_node_and_tolerations | nindent 12 }}
          extraEnv:
            - name: VAULT_SKIP_VERIFY
              value: "true"
          installCRDs: true
          extraObjects:
            - apiVersion: external-secrets.io/v1
              kind: ClusterSecretStore
              metadata:
                name: vault-backend
                annotations:
                  argocd.argoproj.io/sync-wave: "4"
              spec:
                retrySettings:
                  maxRetries: 5
                  retryInterval: "10s"
                provider:
                  vault:
                    server: "https://vault-active.glueops-core-vault.svc.cluster.local:8200"
                    path: "secret"
                    version: "v2"
                    auth:
                      # Authenticate against Vault using a Kubernetes ServiceAccount
                      # token stored in a Secret.
                      # https://www.vaultproject.io/docs/auth/kubernetes
                      kubernetes:
                        # Path where the Kubernetes authentication backend is mounted in Vault
                        mountPath: "kubernetes"
                        # A required field containing the Vault Role to assume.
                        role: "reader-role"
                        # Optional service account field containing the name
                        # of a kubernetes ServiceAccount
                        serviceAccountRef:
                          name: "external-secrets-read-all-from-vault"
                          namespace: "glueops-core-external-secrets"
            - apiVersion: v1
              kind: ServiceAccount
              metadata:
                name: external-secrets-read-all-from-vault
                annotations:
                  argocd.argoproj.io/sync-wave: "3"
            - apiVersion: batch/v1
              kind: Job
              metadata:
                name: glueops-core-vault-health-check-job
                namespace: glueops-core-external-secrets
                annotations:
                  # This needs to run first to ensure vault is online before using vault as a dependency.
                  argocd.argoproj.io/sync-wave: "1"
                  argocd.argoproj.io/hook: Sync
              spec:
                # The number of times to retry the job before marking it as failed.
                backoffLimit: 3
                template:
                  spec:
                    # This ensures the pod does not restart within the job. The job controller handles retries.
                    restartPolicy: Never
                    containers:
                    - name: health-checker
                      # Using a lightweight, specific curl image.
                      image: {{ .Values.container_images.app_curlimages.curl.image.registry }}/{{ .Values.container_images.app_curlimages.curl.image.repository }}:{{ .Values.container_images.app_curlimages.curl.image.tag }}
                      command:
                        - /bin/sh
                        - -c
                        - |
                          set -e
                          echo "---"
                          echo "Starting Sync Wave health check for Vault/OpenBao."
                          echo "The sync will NOT proceed until Vault is unsealed and active/standby."
                          echo "---"

                          # Define the Vault health endpoint to check.
                          VAULT_SERVICE_URL="https://vault.glueops-core-vault.svc:8200/v1/sys/health"

                          echo "--- Checking service: $VAULT_SERVICE_URL ---"
                          ATTEMPTS=0
                          MAX_ATTEMPTS=30
                          SLEEP_SECONDS=10

                          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
                            echo "Attempting to check Vault health (Attempt $((ATTEMPTS+1))/${MAX_ATTEMPTS})..."
                            
                            # Use curl to get the HTTP status code from the health endpoint.
                            # A non-zero exit code from curl is ignored (|| true) so the script can check the HTTP_CODE.
                            HTTP_CODE=$(curl -k --silent --output /dev/null --write-out "%{http_code}" --connect-timeout 5 $VAULT_SERVICE_URL) || true
                            
                            # Check if the status code indicates a healthy state (200=active, 429=standby)
                            if [ "$HTTP_CODE" = "200" ]; then
                              echo "Vault is initialized, unsealed, and active. Health check successful."
                              exit 0
                            elif [ "$HTTP_CODE" = "429" ]; then
                              echo "Vault is initialized, unsealed, and in standby mode. Health check successful."
                              exit 0
                            else
                              echo "Vault not ready yet. Received HTTP status code: $HTTP_CODE. Retrying in ${SLEEP_SECONDS} seconds..."
                            fi
                            
                            ATTEMPTS=$((ATTEMPTS+1))
                            sleep $SLEEP_SECONDS
                          done
                          
                          echo "Vault did not become ready in time. Failing sync wave."
                          exit 1

