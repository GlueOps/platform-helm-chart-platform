apiVersion: v1
kind: ServiceAccount
metadata:
  name: qr-secrets-bootstrap
  namespace: glueops-core
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-11"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: qr-secrets-bootstrap
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-11"
    # keep RBAC stable; recreate before next hook run, but don't delete on success
    "helm.sh/hook-delete-policy": before-hook-creation
rules:
  - apiGroups: [""]
    resources: ["secrets", "namespaces"]
    verbs: ["get", "list", "create", "patch", "update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: qr-secrets-bootstrap
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-11"
    # keep RBAC stable; recreate before next hook run, but don't delete on success
    "helm.sh/hook-delete-policy": before-hook-creation
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: qr-secrets-bootstrap
subjects:
  - kind: ServiceAccount
    name: qr-secrets-bootstrap
    namespace: glueops-core
---
apiVersion: batch/v1
kind: Job
metadata:
  name: qr-secrets-bootstrap
  namespace: glueops-core
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "-10"
    argocd.argoproj.io/sync-wave: "-10"
spec:
  backoffLimit: 2
  template:
    spec:
      serviceAccountName: qr-secrets-bootstrap
      restartPolicy: Never
      containers:
        - name: kubectl
          image: bitnami/kubectl:latest
          command: ["/bin/sh","-c"]
          env:
            - name: NS_BOT
              value: glueops-core-pull-request-bot
            - name: NS_QR
              value: glueops-core-qr-code-generator
            - name: SECRET_NAME
              value: qr-shared
          args:
            - |
              set -eu

              TMP_FILES=""
              
              cleanup() {
                for f in $TMP_FILES; do
                  if [ -f "$f" ]; then
                    rm -f "$f"
                  fi
                done
              }
              trap cleanup EXIT

              can_access_ns () {
                kubectl -n "$1" get secret >/dev/null 2>&1
              }

              echo "Checking whether we can access target namespaces..."
              BOT_OK=0
              QR_OK=0
              can_access_ns "$NS_BOT" && BOT_OK=1
              can_access_ns "$NS_QR" && QR_OK=1

              if [ "$BOT_OK" -eq 0 ] && [ "$QR_OK" -eq 0 ]; then
                echo "Cannot access $NS_BOT or $NS_QR yet (namespace may not exist); exiting successfully."
                exit 0
              fi

              echo "Getting existing QR_MINT_TOKEN (prefer $NS_BOT, fallback $NS_QR)..."
              MINT=""

              if [ "$BOT_OK" -eq 1 ]; then
                MINT="$(kubectl -n "$NS_BOT" get secret "$SECRET_NAME" -o jsonpath='{.data.QR_MINT_TOKEN}' 2>/dev/null | base64 -d 2>/dev/null || true)"
              fi
              if [ -z "${MINT}" ] && [ "$QR_OK" -eq 1 ]; then
                MINT="$(kubectl -n "$NS_QR" get secret "$SECRET_NAME" -o jsonpath='{.data.QR_MINT_TOKEN}' 2>/dev/null | base64 -d 2>/dev/null || true)"
              fi

              if [ -z "${MINT}" ]; then
                echo "No existing QR_MINT_TOKEN found; generating..."
                MINT="$(head -c 32 /dev/urandom | base64 | tr -d '\n')"
              else
                echo "Found existing QR_MINT_TOKEN; reusing."
              fi

              echo "Ensuring QR_SIGNING_SECRET exists (only used in $NS_QR)..."
              SIGN=""
              if [ "$QR_OK" -eq 1 ]; then
                SIGN="$(kubectl -n "$NS_QR" get secret "$SECRET_NAME" -o jsonpath='{.data.QR_SIGNING_SECRET}' 2>/dev/null | base64 -d 2>/dev/null || true)"
              fi
              if [ -z "${SIGN}" ]; then
                echo "No existing QR_SIGNING_SECRET found; generating..."
                SIGN="$(head -c 32 /dev/urandom | base64 | tr -d '\n')"
              else
                echo "Found existing QR_SIGNING_SECRET; reusing."
              fi

              echo "Applying secrets..."
              if [ "$BOT_OK" -eq 1 ]; then
                TMP_YAML_BOT=$(mktemp)
                TMP_FILES="$TMP_FILES $TMP_YAML_BOT"
                kubectl -n "$NS_BOT" create secret generic "$SECRET_NAME" \
                  --from-literal=QR_MINT_TOKEN="$MINT" \
                  --dry-run=client -o yaml > "$TMP_YAML_BOT"
                kubectl apply -f "$TMP_YAML_BOT"
              else
                echo "Skipping $NS_BOT (cannot access)."
              fi

              if [ "$QR_OK" -eq 1 ]; then
                TMP_YAML_QR=$(mktemp)
                TMP_FILES="$TMP_FILES $TMP_YAML_QR"
                kubectl -n "$NS_QR" create secret generic "$SECRET_NAME" \
                  --from-literal=QR_MINT_TOKEN="$MINT" \
                  --from-literal=QR_SIGNING_SECRET="$SIGN" \
                  --dry-run=client -o yaml > "$TMP_YAML_QR"
                kubectl apply -f "$TMP_YAML_QR"
              else
                echo "Skipping $NS_QR (cannot access)."
              fi

              echo "Done."
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: glueops-core-pull-request-bot
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  destination:
    name: "in-cluster"
    namespace: glueops-core-pull-request-bot
  project: glueops-core
  syncPolicy:
    syncOptions:
      - Replace=true
      - CreateNamespace=true
    automated:
      prune: true
      selfHeal: true
    retry:
      backoff:
        duration: 5s
        maxDuration: 3m0s
        factor: 2
      limit: 2
  source:
    repoURL: https://helm.gpkg.io/project-template
    chart: app
    targetRevision: 0.9.0
    helm:
      values: |
        appName: 'pull-request-bot'
        image:
          registry: {{ .Values.container_images.app_pull_request_bot.pull_request_bot.image.registry }}
          repository: {{ .Values.container_images.app_pull_request_bot.pull_request_bot.image.repository }}
          tag: {{ .Values.container_images.app_pull_request_bot.pull_request_bot.image.tag }}
          pullPolicy: IfNotPresent
        serviceAccount:
          create: true
          name: pull-request-bot
        deployment:
          envSecrets:
            - variable: QR_MINT_TOKEN
              secretName: qr-shared
              secretKey: QR_MINT_TOKEN
          envVariables:
            - name: WATCH_FOR_APPS_DELAY_SECONDS
              value: {{ .Values.pull_request_bot.watch_for_apps_delay_seconds }}
          {{- toYaml .Values.glueops_node_and_tolerations | nindent 10 }}
          serviceAccount:
            enabled: true
            name: pull-request-bot
          replicas: 1
          enabled: true
          imagePullPolicy: IfNotPresent
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
        customResources:
          - |-
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
              name: pull-request-bot
            rules:
            - apiGroups: [""]
              resources: ["secrets", "configmaps"]
              verbs: ["get", "list", "watch"]
            - apiGroups: ["argoproj.io"]
              resources: ["applications","applicationsets"]
              verbs: ["list"]
          - |-
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: pull-request-bot
            subjects:
            - kind: ServiceAccount
              name: pull-request-bot
              namespace: glueops-core-pull-request-bot
            roleRef:
              kind: ClusterRole
              name: pull-request-bot
              apiGroup: rbac.authorization.k8s.io
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: glueops-core-qr-code-generator
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  destination:
    name: "in-cluster"
    namespace: glueops-core-qr-code-generator
  project: glueops-core
  syncPolicy:
    syncOptions:
      - Replace=true
      - CreateNamespace=true
    automated:
      prune: true
      selfHeal: true
    retry:
      backoff:
        duration: 10s
        maxDuration: 3m0s
        factor: 2
      limit: 5
  source:
    repoURL: 'https://helm.gpkg.io/project-template'
    chart: app
    targetRevision: 0.9.0
    helm:
      values: |-
        appName: 'qr-code-generator'
        replicaCount: '2'
        image:
          registry: {{ .Values.container_images.app_qr_code_generator.qr_code_generator.image.registry }}
          repository: {{ .Values.container_images.app_qr_code_generator.qr_code_generator.image.repository }}
          tag: {{ .Values.container_images.app_qr_code_generator.qr_code_generator.image.tag }}
          pullPolicy: IfNotPresent
          port: 8000

        deployment:
          enabled: true
          {{- toYaml .Values.glueops_node_and_tolerations | nindent 10 }}
          envSecrets:
            - variable: QR_MINT_TOKEN
              secretName: qr-shared
              secretKey: QR_MINT_TOKEN
            - variable: QR_SIGNING_SECRET
              secretName: qr-shared
              secretKey: QR_SIGNING_SECRET

        service:
          enabled: true
          type: ClusterIP
          ports:
            - port: 80
              name: qr-code-generator
              protocol: TCP
              targetPort: 8000

        ingress:
          enabled: true
          ingressClassName: public-traefik
          entries:
            - name: public
              hosts:
                - hostname: qr-code-generator.{{ .Values.captain_domain }}
                  paths:
                    - path: /
                      pathType: Prefix
                      servicePortNumber: 80
